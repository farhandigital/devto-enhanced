# Code Safety Guide

> **Generated by Claude AI**  
> This guide documents the safety principles and defensive programming patterns used in this project.

## Table of Contents

- [Philosophy](#philosophy)
- [Defense at the Right Layer](#defense-at-the-right-layer)
- [Compile-Time Safety](#compile-time-safety)
- [Runtime Safety](#runtime-safety)
- [Project-Specific Guidelines](#project-specific-guidelines)
- [Common Pitfalls](#common-pitfalls)
- [Code Review Checklist](#code-review-checklist)

---

## Philosophy

**Core Principle:** Prefer compile-time safety over runtime safety whenever compile-time can guarantee prevention of the error class.

**Why?**
- Fails fast during development, not in production
- Zero runtime cost (no try/catch overhead, no conditional checks)
- Self-documenting through types
- Better IDE support and refactoring safety

**However:** Runtime safety is still essential for handling external uncertainties (DOM state, async operations, user input, third-party APIs).

---

## Defense at the Right Layer

Don't add runtime guards to compensate for weak types. Instead, choose the appropriate defense mechanism for each type of problem:

| Problem | ❌ Wrong Solution | ✅ Right Solution |
|---------|------------------|------------------|
| Property might be undefined | `try/catch` around every access | `strictNullChecks: true` + proper types |
| Function might not exist | Runtime check before calling | Proper interface definition |
| Settings schema changed | Defensive merging everywhere | Storage migrations (WXT provides this) |
| Data from external API | Hope it matches types | Runtime validation (Zod, io-ts) → then trust types |
| Complex DOM manipulation | Nothing | Try/catch + graceful degradation |

---

## Compile-Time Safety

### TypeScript Strict Mode

**Required Configuration:**
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

### What Compile-Time Safety Covers

#### 1. **Type Guarantees**

```typescript
// Feature callbacks are strongly typed
isEnabled: (settings: ExtensionSettings) => boolean

// TypeScript guarantees this won't throw at runtime
isEnabled: (settings) => settings.article.hideRightSidebar
```

If `hideRightSidebar` doesn't exist in `ExtensionSettings['article']`, you get a **compile error**, not a runtime crash.

#### 2. **Exhaustive Type Checking**

```typescript
// From types/index.ts
export type PageContext = "global" | "home" | "article" | "other";

// Compile-time guarantee all contexts are handled
const _assertComplete: FeatureGroupContext extends (typeof ORDERED_CONTEXTS)[number]
  ? true
  : "ERROR: ORDERED_CONTEXTS is missing some FeatureGroupContext values" = true;
```

#### 3. **Settings Schema Consistency**

```typescript
// Single source of truth
export interface ExtensionSettings {
  global: { hideSubforemSwitcher: boolean };
  home: { hideLeftSidebar: boolean; hideRightSidebar: boolean };
  article: { /* ... */ };
}

// Type-safe updates
async function updateSetting<K extends keyof ExtensionSettings>(
  section: K,
  key: keyof ExtensionSettings[K],  // ← Only valid keys allowed
  value: boolean,
) { /* ... */ }
```

---

## Runtime Safety

### When Runtime Guards ARE Needed

Runtime errors occur at the **boundary between your code and the external world**:

1. **DOM manipulation** — dev.to can change their HTML structure
2. **Async operations** — promises can reject, network can fail
3. **Browser APIs** — permissions can be denied
4. **Timing issues** — race conditions, elements not yet rendered
5. **User input** — always untrusted

### Our Codebase's Runtime Boundaries

| Component | External Dependency | Failure Mode |
|-----------|-------------------|--------------|
| Feature `execute()` functions | dev.to's DOM structure | Selectors don't match |
| `navigator.clipboard` | User permissions | Promise rejection |
| `IntersectionObserver` | Async callbacks | Stale DOM references |
| Storage API | Browser storage | Quota exceeded, corrupted data |
| Dynamic imports | Module loading | Network/bundler issues |

### Defensive Pattern: Early Exit

**Used throughout our features:**

```typescript
// readingStats.ts
execute: (settings: ExtensionSettings) => {
  const articleBody = document.querySelector(Selectors.article.body);
  const titleHeader = document.querySelector(Selectors.article.titleHeaderContainer);
  
  if (!articleBody || !titleHeader) return;  // ← Graceful exit
  
  // Safe to proceed
  const { words, minutes } = calculateReadingStats(articleBody);
  // ...
}
```

**Why this works:**
- Features are enhancements, not critical functionality
- Silent failure is acceptable (user just doesn't see the feature)
- No error thrown to the console unless truly exceptional

### Defensive Pattern: Try/Catch at Execution Boundaries

**Already implemented in `registry.ts`:**

```typescript
export function executeFeatures(
  pageContext: PageContext,
  settings: ExtensionSettings,
): void {
  getFeaturesForContext(pageContext).forEach((feature) => {
    if (feature.execute) {
      try {
        feature.execute(settings);  // ← Protected boundary
      } catch (error) {
        console.error(`Failed to execute feature "${feature.name}":`, error);
      }
    }
  });
}
```

**This pattern isolates feature failures** — one buggy feature doesn't crash all features.

### Defensive Pattern: Async Error Handling

**Used in `copyArticle.ts`:**

```typescript
async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error("Failed to copy to clipboard:", err);
    return false;  // ← Graceful degradation
  }
}
```

**Then handled at UI level:**

```typescript
const success = await copyToClipboard(content);
if (success) {
  button.innerHTML = `✓ Copied!`;
} else {
  button.innerHTML = `✗ Failed`;
}
```

---

## Project-Specific Guidelines

### Storage Safety

**WXT's `storage.defineItem` with `defaultValue` guarantees:**

```typescript
export const settingsStorage = storage.defineItem<ExtensionSettings>(
  "local:settings",
  { defaultValue: DEFAULT_SETTINGS },  // ← Always returns full object
);

// getValue() NEVER returns undefined or partial data
const settings = await settingsStorage.getValue();
```

**Therefore:**
- ❌ Don't add defensive merging in every function
- ✅ Use storage migrations for schema changes
- ✅ Trust that `settings` matches `ExtensionSettings` type

### Feature Callback Safety

**Simple predicate callbacks don't need try/catch:**

```typescript
// This is safe because TypeScript enforces the property exists
isEnabled: (settings) => settings.article.hideRightSidebar

// This would be a COMPILE ERROR if the property didn't exist:
isEnabled: (settings) => settings.article.nonExistentProperty
//                                         ^^^^^^^^^^^^^^^^^^
// Property 'nonExistentProperty' does not exist on type...
```

**Complex callbacks with external dependencies DO need guards:**

```typescript
// If you were doing something like this (hypothetical):
isEnabled: (settings) => {
  const element = document.querySelector('.some-selector');
  return element?.classList.contains('active') ?? false;
  //            ^ Optional chaining for safety
}
```

**Guideline:** If your callback only accesses typed properties, TypeScript is sufficient. If it touches the DOM or external APIs, add defensive checks.

### DOM Query Safety

**Pattern used throughout features:**

```typescript
// 1. Query with null awareness
const element = document.querySelector(Selectors.article.body);

// 2. Early exit if not found
if (!element) return;

// 3. Now safe to use
element.classList.add('my-class');
```

**Never assume DOM structure:**
```typescript
// ❌ BAD: Assumes element exists
document.querySelector(Selectors.article.body).classList.add('class');
//                                            ^
// Potential: Cannot read property 'classList' of null

// ✅ GOOD: Defensive
const element = document.querySelector(Selectors.article.body);
if (element) {
  element.classList.add('class');
}
```

### Dynamic Import Safety

**Current implementation in `App.svelte`:**

```typescript
function initializeFeatureGroups() {
  import("@/features/definitions")
    .then(() => {
      featureGroups = getUIFeatureGroups();
    })
    .catch((error) => {
      console.error("Failed to load feature definitions:", error);
    });
}
```

**Why this is sufficient:**
- The import is for bundled code (not external network)
- Failure would indicate a serious bundler/build issue
- Console error provides debugging info
- UI shows "no features" state (implicit degradation)

**When to await:**
```typescript
// If you need features loaded before UI renders:
onMount(async () => {
  try {
    await import("@/features/definitions");
    featureGroups = getUIFeatureGroups();
  } catch (error) {
    console.error("Failed to load features:", error);
    loadError = "Failed to load features";
  } finally {
    isLoading = false;
  }
});
```

---

## Common Pitfalls

### ❌ Pitfall 1: Over-Engineering with Try/Catch

```typescript
// ❌ OVERKILL: Adding try/catch for operations that can't throw
function getSettingValue(feature: FeatureMetadata): boolean {
  try {
    const { section, key } = feature.settingKey;
    return settings[section][key] ?? false;
  } catch (error) {
    console.error("Failed to get setting:", error);
    return false;
  }
}
```

**Why this is overkill:**
- Property access on typed objects doesn't throw
- If `settings` matches `ExtensionSettings`, this never fails
- The `?? false` already handles undefined (though TypeScript should prevent it)

**Better:**
```typescript
function getSettingValue(feature: FeatureMetadata): boolean {
  const { section, key } = feature.settingKey;
  const sectionSettings = settings[section];
  return (sectionSettings as Record<string, boolean>)[key as string] ?? false;
}
```

### ❌ Pitfall 2: Runtime Checks for Type Problems

```typescript
// ❌ BAD: Trying to fix type issues at runtime
async function updateSetting(section: string, key: string, value: any) {
  const current = await settingsStorage.getValue();
  
  // Defensive merge because types aren't strong enough
  const updated = {
    ...DEFAULT_SETTINGS,
    ...current,
    [section]: {
      ...DEFAULT_SETTINGS[section],
      ...current[section],
      [key]: value,
    },
  };
  
  await settingsStorage.setValue(updated);
}
```

**✅ BETTER: Fix the types**
```typescript
async function updateSetting<K extends keyof ExtensionSettings>(
  section: K,
  key: keyof ExtensionSettings[K],
  value: boolean,
) {
  const current = await settingsStorage.getValue();
  await settingsStorage.setValue({
    ...current,
    [section]: {
      ...current[section],
      [key]: value,
    },
  });
}
```

Now TypeScript prevents invalid calls at compile time.

### ❌ Pitfall 3: Ignoring Async Failures

```typescript
// ❌ BAD: Fire-and-forget async without error handling
async function handleToggle(feature: FeatureMetadata, e: Event) {
  const target = e.target as HTMLInputElement;
  const { section, key } = feature.settingKey;
  
  updateSetting(section, key, target.checked);  // ← Unhandled promise
}
```

**✅ GOOD: Handle async errors**
```typescript
async function handleToggle(feature: FeatureMetadata, e: Event) {
  const target = e.target as HTMLInputElement;
  const { section, key } = feature.settingKey;
  
  try {
    await updateSetting(section, key, target.checked);
  } catch (error) {
    console.error("Failed to update setting:", error);
    target.checked = !target.checked;  // Revert UI
  }
}
```

---

## Code Review Checklist

### For New Features

- [ ] **Type Safety**
  - [ ] All feature callbacks properly typed with `ExtensionSettings`
  - [ ] No use of `any` type (use `unknown` if truly needed)
  - [ ] Setting keys exist in `ExtensionSettings` interface

- [ ] **DOM Safety**
  - [ ] All `querySelector` results checked for null before use
  - [ ] Early return pattern used when DOM doesn't match expectations
  - [ ] Optional chaining (`?.`) used for uncertain property access

- [ ] **Error Boundaries**
  - [ ] Feature `execute()` can throw? → Already wrapped by registry
  - [ ] Async operations have try/catch
  - [ ] User-facing errors provide feedback (not silent failures)

- [ ] **Cleanup**
  - [ ] `cleanup()` function provided if feature modifies DOM
  - [ ] Observers/timers properly disconnected
  - [ ] Optional chaining in cleanup (`element?.remove()`)

### For Settings Changes

- [ ] **Schema Updates**
  - [ ] New settings added to `ExtensionSettings` interface
  - [ ] `DEFAULT_SETTINGS` updated with default values
  - [ ] Consider if migration is needed for existing users

- [ ] **Backward Compatibility**
  - [ ] Will old stored settings still work?
  - [ ] Has `defaultValue` guaranteed safety?

### For Popup Changes

- [ ] **Loading States**
  - [ ] UI doesn't render until critical data loaded
  - [ ] Error states displayed to user
  - [ ] Loading indicators for async operations

- [ ] **Type Consistency**
  - [ ] Settings interface matches what features expect
  - [ ] No casting without type guards

---

## Summary

**Defense in Depth ≠ Redundant Defenses**

It means **layered defenses against different failure modes at appropriate layers:**

| Layer | Defends Against | Tool |
|-------|----------------|------|
| Type System | Developer mistakes, invalid data structures | TypeScript strict mode |
| Build | Import errors, dead code | Bundler, tree-shaking |
| Feature Registry | One feature crashing all features | Try/catch at execution boundary |
| Individual Features | DOM not matching expectations | Early exit pattern |
| UI | Async failures, user errors | Try/catch + user feedback |

**When in doubt:**
1. Can TypeScript prevent this error? → Use types
2. Is this external uncertainty? → Use runtime checks
3. Is this a critical path? → Add error handling
4. Is this an enhancement? → Fail gracefully

**Questions to ask:**
- "What external systems does this code interact with?"
- "What assumptions am I making about runtime state?"
- "If this fails, should the whole app crash or just this feature?"

The goal is not to catch every possible error, but to ensure errors are:
1. **Prevented when possible** (compile-time)
2. **Isolated when they occur** (boundaries)
3. **Visible for debugging** (logging)
4. **Graceful for users** (degradation)
